{{- define "app_go" -}}
package internal

import (
	"context"
	"fmt"
	"log/slog"
	"net"
	"net/http"
	"net/http/pprof"
	"time"

	"{{ .Module }}/internal/config"
	generatedserver "{{ .Module }}/internal/generated/server"
	"{{ .Module }}/internal/api/rest"
	{{ if .UseRealtimeJWT }}
	wsapi "{{ .Module }}/internal/api/ws"
	wsmiddlewares "{{ .Module }}/internal/api/ws/middlewares"
	"{{ .Module }}/internal/contract"
	"{{ .Module }}/internal/domain"
	"{{ .Module }}/internal/services/realtime"
	"{{ .Module }}/internal/services/tokenizer"
	{{ end }}
	"{{ .Module }}/pkg/httpserver"

	"github.com/julienschmidt/httprouter"
	"github.com/prometheus/client_golang/prometheus/promhttp"
	"github.com/rom8726/di"
	"golang.org/x/sync/errgroup"
	{{ .DB.Processor.Import }}
	{{- range .Infras }}
    {{ .Processor.Import }}
    {{- end }}
)

const (
	ctxTimeout = 10 * time.Second
)

type App struct {
	Config *config.Config
	Logger *slog.Logger

	{{ .DB.Processor.StructField }}
	{{- range .Infras }}
    {{ .Processor.StructField }}
    {{- end }}

	APIServer *httpserver.Server
	{{ if .UseRealtimeJWT }}WSServer *httpserver.Server{{ end }}

	container *di.Container
	diApp     *di.App
}

func NewApp(ctx context.Context, cfg *config.Config, logger *slog.Logger) (*App, error) {
	ctx, cancel := context.WithTimeout(ctx, ctxTimeout)
	defer cancel()

	{{ .DB.Processor.InitInAppConstructor }}

    {{- range .Infras }}
    {{ .Processor.InitInAppConstructor }}
    {{- end }}

	container := di.New()
	diApp := di.NewApp(container)

	app := &App{
		Config:       cfg,
		Logger:       logger,
		container:    container,
		diApp:        diApp,
		{{ .DB.Processor.FillStructField }}
		{{- range .Infras }}
		{{ .Processor.FillStructField }}
		{{- end }}
    }

	app.registerComponents()

	app.APIServer, err = app.newAPIServer()
	if err != nil {
		return nil, fmt.Errorf("create API server: %w", err)
	}

	{{ if .UseRealtimeJWT }}
	app.WSServer, err = app.newWSServer()
	if err != nil {
		return nil, fmt.Errorf("create WS server: %w", err)
	}
	{{ end }}

	return app, nil
}

func (app *App) RegisterComponent(constructor any) *di.Provider {
	return app.container.Provide(constructor)
}

func (app *App) ResolveComponent(target any) error {
	return app.container.Resolve(target)
}

func (app *App) ResolveComponentsToStruct(target any) error {
	return app.container.ResolveToStruct(target)
}

func (app *App) Run(ctx context.Context) error {
	techServer, err := app.newTechServer()
	if err != nil {
		return fmt.Errorf("create tech server: %w", err)
	}

	app.Logger.Info("Start API server")

	group, groupCtx := errgroup.WithContext(ctx)
	group.Go(func() error { return app.APIServer.ListenAndServe(groupCtx) })
	group.Go(func() error { return techServer.ListenAndServe(groupCtx) })
	{{ if .UseRealtimeJWT }}group.Go(func() error { return app.WSServer.ListenAndServe(groupCtx) }){{ end }}
	group.Go(func() error { return app.diApp.Run(groupCtx) })

	return group.Wait()
}

func (app *App) Close() {
	{{ .DB.Processor.Close }}
    {{- range .Infras }}
    {{ .Processor.Close }}
    {{- end }}
}

func (app *App) registerComponent(constructor any) *di.Provider {
	return app.container.Provide(constructor)
}

func (app *App) registerComponents() {
	app.registerComponent(rest.New)
	{{ if .HasSecurityHandler }}app.registerComponent(rest.NewSecurityHandler){{ end }}
	{{ if eq .DB.Code "postgresql" }}app.registerComponent(db.NewTxManager).Arg(app.PostgresPool){{end}}
	{{ if .UseRealtimeJWT }}
	app.registerComponent(tokenizer.New).Arg(&tokenizer.ServiceParams{
        SecretKey:  []byte(app.Config.JWT.SecretKey),
        AccessTTL:  app.Config.JWT.AccessTTL,
        RefreshTTL: app.Config.JWT.RefreshTTL,
    })
	app.registerComponent(realtime.New)
	app.registerComponent(newStubEventsFetcher)
	{{ end }}
	// TODO: register service components
}

func (app *App) newAPIServer() (*httpserver.Server, error) {
	cfg := app.Config.APIServer

	var restAPI generatedserver.Handler
	if err := app.container.Resolve(&restAPI); err != nil {
		return nil, fmt.Errorf("resolve REST API service component: %w", err)
	}

	{{ if .HasSecurityHandler }}
	var securityHandler generatedserver.SecurityHandler
	if err := app.container.Resolve(&securityHandler); err != nil {
		return nil, fmt.Errorf("resolve API security handler component: %w", err)
	}

	genServer, err := generatedserver.NewServer(restAPI, securityHandler)
	{{ else }}
	genServer, err := generatedserver.NewServer(restAPI)
	{{ end }}
	if err != nil {
		return nil, fmt.Errorf("create API server: %w", err)
	}

	lis, err := net.Listen("tcp", cfg.Addr)
	if err != nil {
		return nil, fmt.Errorf("listen %q: %w", cfg.Addr, err)
	}

	return &httpserver.Server{
		Listener:     lis,
		ReadTimeout:  cfg.ReadTimeout,
		WriteTimeout: cfg.WriteTimeout,
		IdleTimeout:  cfg.IdleTimeout,
		Handler:      genServer,
	}, nil
}

func (app *App) newTechServer() (*httpserver.Server, error) {
	cfg := app.Config.TechServer
	lis, err := net.Listen("tcp", cfg.Addr)
	if err != nil {
		return nil, fmt.Errorf("listen %q: %w", cfg.Addr, err)
	}

	router := httprouter.New()
	router.Handle(http.MethodGet, "/health",
		func(writer http.ResponseWriter, _ *http.Request, _ httprouter.Params) {
			writer.WriteHeader(http.StatusOK)
			_, _ = writer.Write([]byte("ok"))
		},
	)

	router.Handler(http.MethodGet, "/metrics", promhttp.Handler())

	router.HandlerFunc(http.MethodGet, "/debug/pprof", pprof.Index)
	router.HandlerFunc(http.MethodGet, "/debug/pprof/cmdline", pprof.Cmdline)
	router.HandlerFunc(http.MethodGet, "/debug/pprof/profile", pprof.Profile)
	router.HandlerFunc(http.MethodGet, "/debug/pprof/symbol", pprof.Symbol)
	router.HandlerFunc(http.MethodGet, "/debug/pprof/trace", pprof.Trace)
	router.Handler(http.MethodGet, "/debug/pprof/allocs", pprof.Handler("allocs"))
	router.Handler(http.MethodGet, "/debug/pprof/block", pprof.Handler("block"))
	router.Handler(http.MethodGet, "/debug/pprof/goroutine", pprof.Handler("goroutine"))
	router.Handler(http.MethodGet, "/debug/pprof/heap", pprof.Handler("heap"))
	router.Handler(http.MethodGet, "/debug/pprof/mutex", pprof.Handler("mutex"))
	router.Handler(http.MethodGet, "/debug/pprof/threadcreate", pprof.Handler("threadcreate"))

	return &httpserver.Server{
		Listener:     lis,
		ReadTimeout:  cfg.ReadTimeout,
		WriteTimeout: cfg.WriteTimeout,
		IdleTimeout:  cfg.IdleTimeout,
		Handler:      router,
	}, nil
}

{{ if .UseRealtimeJWT }}
// newWSServer creates a dedicated WebSocket server on a separate port.
func (app *App) newWSServer() (*httpserver.Server, error) {
	cfg := app.Config.WSServer

	var tokenizerSrv contract.Tokenizer
	if err := app.container.Resolve(&tokenizerSrv); err != nil {
		return nil, fmt.Errorf("resolve tokenizer service component: %w", err)
	}

	var rtSvc *realtime.Service
	if err := app.container.Resolve(&rtSvc); err != nil {
		return nil, fmt.Errorf("resolve realtime service component: %w", err)
	}

	wsHandler := wsmiddlewares.WSAuthMiddleware(tokenizerSrv)(wsapi.New(rtSvc.Broadcaster()))

	router := httprouter.New()
	router.Handler(http.MethodGet, "/api/ws", wsHandler)

	lis, err := net.Listen("tcp", cfg.Addr)
	if err != nil {
		return nil, fmt.Errorf("listen %q: %w", cfg.Addr, err)
	}

	return &httpserver.Server{
		Listener:     lis,
		ReadTimeout:  cfg.ReadTimeout,
		WriteTimeout: cfg.WriteTimeout,
		IdleTimeout:  cfg.IdleTimeout,
		Handler:      router,
	}, nil
}

// stubEventsFetcher is a stub implementation of contract.EventsFetcher.
// Replace it with your own implementation that fetches real events.
type stubEventsFetcher struct{}

func newStubEventsFetcher() *stubEventsFetcher {
	return &stubEventsFetcher{}
}

func (s *stubEventsFetcher) FetchAfter(_ context.Context, _ time.Time) ([]domain.RealtimeEvent, error) {
	return nil, nil
}
{{ end }}

{{ .DB.Processor.Constructor }}

{{- range .Infras }}
{{ .Processor.Constructor }}
{{- end }}
{{ end }}