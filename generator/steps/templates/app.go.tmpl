{{ define "app_go" }}package internal

import (
	"context"
	"fmt"
	"log/slog"
	"net"
	"time"

	"github.com/jackc/pgx/v5/pgxpool"
	"github.com/julienschmidt/httprouter"
	"github.com/rom8726/di"
	"golang.org/x/sync/errgroup"

	"{{ .Module }}/internal/api/rest"
	"{{ .Module }}/internal/config"
	generatedserver "{{ .Module }}/internal/generated/server"
	"{{ .Module }}/pkg/httpserver"
)

const (
	ctxTimeout = 10 * time.Second
)

type App struct {
	Config *config.Config
	Logger *slog.Logger

	{{ if .UsePostgres }}PostgresPool *pgxpool.Pool{{ end }}

	container *di.Container
	diApp     *di.App
}

func NewApp(ctx context.Context, cfg *config.Config, logger *slog.Logger) (*App, error) {
	ctx, cancel := context.WithTimeout(ctx, ctxTimeout)
	defer cancel()

	{{ if .UsePostgres }}
	pgPool, err := newPostgresConnPool(ctx, &cfg.Postgres)
	if err != nil {
		return nil, fmt.Errorf("create postgres pool: %w", err)
	}
	{{ end }}

	container := di.New()
	diApp := di.NewApp(container)

	return &App{
		Config:       cfg,
		Logger:       logger,
		PostgresPool: pgPool,
		container:    container,
		diApp:        diApp,
	}, nil
}

func (app *App) RegisterComponent(constructor any) *di.Provider {
	return app.container.Provide(constructor)
}

func (app *App) ResolveComponent(target any) error {
	return app.container.Resolve(target)
}

func (app *App) ResolveComponentsToStruct(target any) error {
	return app.container.ResolveToStruct(target)
}

func (app *App) Run(ctx context.Context) error {
	apiServer, err := app.newAPIServer()
	if err != nil {
		return fmt.Errorf("create API server: %w", err)
	}

	techServer, err := app.newTechServer()
	if err != nil {
		return fmt.Errorf("create tech server: %w", err)
	}

	app.Logger.Info("Start API server")

	group, groupCtx := errgroup.WithContext(ctx)
	group.Go(func() error { return apiServer.ListenAndServe(groupCtx) })
	group.Go(func() error { return techServer.ListenAndServe(groupCtx) })
	group.Go(func() error { return app.diApp.Run(groupCtx) })

	return group.Wait()
}

func (app *App) Close() {
	{{ if .UsePostgres }}
	if app.PostgresPool != nil {
		app.PostgresPool.Close()
	}
	{{ end }}
}

func (app *App) newAPIServer() (*httpserver.Server, error) {
	cfg := app.Config.APIServer

	var restAPI *rest.RestAPI
	if err := app.container.Resolve(restAPI); err != nil {
		return nil, fmt.Errorf("resolve REST API service component: %w", err)
	}

	genServer, err := generatedserver.NewServer(restAPI)
	if err != nil {
		return nil, fmt.Errorf("create API server: %w", err)
	}

	lis, err := net.Listen("tcp", cfg.Addr)
	if err != nil {
		return nil, fmt.Errorf("listen %q: %w", cfg.Addr, err)
	}

	return &httpserver.Server{
		Listener:     lis,
		ReadTimeout:  cfg.ReadTimeout,
		WriteTimeout: cfg.WriteTimeout,
		IdleTimeout:  cfg.IdleTimeout,
		Handler:      genServer,
	}, nil
}

func (app *App) newTechServer() (*httpserver.Server, error) {
	cfg := app.Config.TechServer
	lis, err := net.Listen("tcp", cfg.Addr)
	if err != nil {
		return nil, fmt.Errorf("listen %q: %w", cfg.Addr, err)
	}

	router := httprouter.New()
	router.Handle(http.MethodGet, "/health",
		func(writer http.ResponseWriter, _ *http.Request, _ httprouter.Params) {
			writer.WriteHeader(http.StatusOK)
			_, _ = writer.Write([]byte("ok"))
		},
	)

	return &httpserver.Server{
		Listener:     lis,
		ReadTimeout:  cfg.ReadTimeout,
		WriteTimeout: cfg.WriteTimeout,
		IdleTimeout:  cfg.IdleTimeout,
		Handler:      router,
	}, nil
}

{{ if .UsePostgres }}
func newPostgresConnPool(ctx context.Context, cfg *config.Postgres) (*pgxpool.Pool, error) {
	pgCfg, err := pgxpool.ParseConfig(cfg.ConnStringWithPoolSize())
	if err != nil {
		return nil, fmt.Errorf("parse config: %w", err)
	}

	pgCfg.MaxConnLifetime = cfg.ConnMaxLifetime
	pgCfg.MaxConnLifetimeJitter = time.Second * 5
	pgCfg.MaxConnIdleTime = cfg.MaxIdleConnTime
	pgCfg.HealthCheckPeriod = time.Second * 5

	pool, err := pgxpool.NewWithConfig(ctx, pgCfg)
	if err != nil {
		return nil, err
	}

	if err := pool.Ping(ctx); err != nil {
		return nil, fmt.Errorf("ping: %w", err)
	}

	return pool, nil
}
{{ end }}
{{ end }}