{{- define "test_runner" -}}
package runner

import (
	"context"
	"fmt"
	"log/slog"
	"net"
	"net/url"
	"os"
	"testing"
	"time"

	"github.com/rom8726/testy"
	"github.com/stretchr/testify/require"
	"github.com/testcontainers/testcontainers-go"
	"github.com/testcontainers/testcontainers-go/modules/postgres"
	"github.com/testcontainers/testcontainers-go/wait"

	"{{ .Module }}/internal"
	"{{ .Module }}/internal/config"
)

type Config struct {
	CasesDir string
}

func Run(t *testing.T, testCfg *Config) {
	t.Helper()

	env := NewEnv()

	postgresContainer, err := postgres.Run(t.Context(),
		"postgres:16",
		postgres.WithDatabase("test_db"),
		postgres.WithUsername("user"),
		postgres.WithPassword("password"),
		testcontainers.WithWaitStrategy(
			wait.ForLog("database system is ready to accept connections").
				WithOccurrence(2).
				WithStartupTimeout(10*time.Second),
		),
	)
	require.NoError(t, err)

	t.Cleanup(func() {
		if err := postgresContainer.Terminate(context.Background()); err != nil {
			t.Fatalf("failed to terminate container: %s", err)
		}
	})

	connStr, err := postgresContainer.ConnectionString(t.Context(), "sslmode=disable")
	require.NoError(t, err)

	pgPort := extractPort(connStr)
	env.Set("POSTGRES_PORT", pgPort)

{{- range $infra := .UseInfra }}
{{- if eq $infra "redis" }}
	// Initialize Redis container
	redisContainer, err := testcontainers.GenericContainer(t.Context(), testcontainers.GenericContainerRequest{
		ContainerRequest: testcontainers.ContainerRequest{
			Image: "redis:7-alpine",
			ExposedPorts: []string{"6379/tcp"},
			Env: map[string]string{
				"REDIS_PASSWORD": "password",
			},
			WaitingFor: wait.ForLog("Ready to accept connections"),
		},
		Started: true,
	})
	require.NoError(t, err)

	t.Cleanup(func() {
		if err := redisContainer.Terminate(context.Background()); err != nil {
			t.Fatalf("failed to terminate redis container: %s", err)
		}
	})

	redisPort, err := redisContainer.MappedPort(t.Context(), "6379")
	require.NoError(t, err)

	env.Set("REDIS_PORT", redisPort.Port())
{{ end }}
{{- if eq $infra "kafka" }}
	// Initialize Kafka container
	kafkaContainer, err := testcontainers.GenericContainer(t.Context(), testcontainers.GenericContainerRequest{
		ContainerRequest: testcontainers.ContainerRequest{
			Image: "bitnami/kafka:3.5",
			ExposedPorts: []string{"9092/tcp"},
			Env: map[string]string{
				"KAFKA_CFG_NODE_ID": "0",
				"KAFKA_CFG_PROCESS_ROLES": "controller,broker",
				"KAFKA_CFG_LISTENERS": "PLAINTEXT://:9092,CONTROLLER://:9093",
				"KAFKA_CFG_LISTENER_SECURITY_PROTOCOL_MAP": "CONTROLLER:PLAINTEXT,PLAINTEXT:PLAINTEXT",
				"KAFKA_CFG_CONTROLLER_QUORUM_VOTERS": "0@kafka:9093",
				"KAFKA_CFG_CONTROLLER_LISTENER_NAMES": "CONTROLLER",
				"ALLOW_PLAINTEXT_LISTENER": "yes",
			},
			WaitingFor: wait.ForLog("Kafka Server started"),
		},
		Started: true,
	})
	require.NoError(t, err)

	t.Cleanup(func() {
		if err := kafkaContainer.Terminate(context.Background()); err != nil {
			t.Fatalf("failed to terminate kafka container: %s", err)
		}
	})

	kafkaPort, err := kafkaContainer.MappedPort(t.Context(), "9092")
	require.NoError(t, err)

	env.Set("KAFKA_PORT", kafkaPort.Port())
	env.Set("KAFKA_BROKERS", fmt.Sprintf("localhost:%s", kafkaPort.Port()))
{{- end }}
{{ end }}
	env.SetUp()
	defer env.CleanUp()

	cfg, err := config.New("")
	if err != nil {
		t.Fatal(err)
	}

	loggerHandler := slog.NewTextHandler(os.Stdout, &slog.HandlerOptions{
		Level: &cfg.Logger,
	})
	logger := slog.New(loggerHandler)
	slog.SetDefault(logger)

	time.Sleep(time.Second * 3)
	app, err := internal.NewApp(t.Context(), cfg, logger)
	if err != nil {
		t.Fatal(err)
	}
	defer app.Close()

	if err := upMigrations(connStr, cfg.MigrationsDir); err != nil {
		t.Fatal(err)
	}

	testyCfg := testy.Config{
		Handler:     app.APIServer.Handler,
		CasesDir:    testCfg.CasesDir,
		FixturesDir: "./fixtures",
		ConnStr:     connStr,
	}
	testy.Run(t, &testyCfg)
}

func extractPort(pgConnStr string) string {
	const defaultPort = "5432"

	if pgConnStr == "" {
		return defaultPort
	}

	if u, err := url.Parse(pgConnStr); err == nil && u.Host != "" {
		if _, port, err := net.SplitHostPort(u.Host); err == nil && port != "" {
			return port
		}
	}

	return defaultPort
}
{{ end }}
